[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I am 7+ years experienced data scientist with background in computer science and artificial intelligence. My work typically ranges but not limited to solving business problems using data, data analysis, and develop machine learning model for production systems that giving impact to millions of users.\nI have experience working remotely with international team, managing data science projects, mentoring, and collaborating with non-technical stakeholders."
  },
  {
    "objectID": "posts/2021-08-23-recreate-visualization-in-matplotlib.html",
    "href": "posts/2021-08-23-recreate-visualization-in-matplotlib.html",
    "title": "Recreate Visualization in Matplotlib",
    "section": "",
    "text": "Last week I watched an interesting video about recreating a D3.js chart using R ggplot. This is the original chart made using D3.js and this is the recreated chart using ggplot.\nIn this post, I’ll go through step by step to recreate the same chart, but using Matplotlib."
  },
  {
    "objectID": "posts/2021-08-23-recreate-visualization-in-matplotlib.html#setup",
    "href": "posts/2021-08-23-recreate-visualization-in-matplotlib.html#setup",
    "title": "Recreate Visualization in Matplotlib",
    "section": "Setup",
    "text": "Setup\nPreparing libraries and utility functions.\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport requests\nimport sys\n\n\nfrom pprint import pprint\n\n\n# plt.style.use(\"seaborn_v0_8\")\nplt.style.use(\"seaborn-v0_8-whitegrid\")\npd.options.display.max_rows = 15\n\n\n\n\nCode\n#########################\n# some utility functions\n#########################\n\nclass Head(object):\n    \n    def __init__(self, lines, fd=sys.stdout):\n        self.lines = lines\n        self.fd = fd\n        \n    def write(self, msg):\n        if self.lines &lt;= 0:\n            return\n        \n        n = msg.count(\"\\n\")\n        if n &lt; self.lines:\n            self.lines -= n\n            return self.fd.write(msg)\n        \n        ix = 0\n        while(self.lines &gt; 0):\n            iy = msg.find('\\n', ix + 1)\n            self.lines -= 1\n            ix = iy\n            \n        return self.fd.write(msg[:ix])\n    \n    \ndef pprint_head(to_print, length=10):\n    \"\"\"\n    Print first few lines of the text\n    \"\"\"\n    pprint(to_print, stream=Head(length))\n    \n    \ndef glimpse(df, rows=10, info=False):\n    \"\"\"\n    Display the first few rows (n) of the given dataframe\n    If info=True, then display the result of dataframe.info() instead\n    \"\"\"\n    if info:\n        display(df.info())\n    else:\n        display(df.head(rows))\n    return df"
  },
  {
    "objectID": "posts/2021-08-23-recreate-visualization-in-matplotlib.html#dataset",
    "href": "posts/2021-08-23-recreate-visualization-in-matplotlib.html#dataset",
    "title": "Recreate Visualization in Matplotlib",
    "section": "Dataset",
    "text": "Dataset\n\nDownload the Raw Data\nThe raw data is in json format and can be downloaded from here.\n\n\nCode\ndata_url = \"https://gist.githubusercontent.com/susielu/625aa4814098671290a8c6bb88a6301e/raw/871576bf6cd336aee813ba97078b97fc91da3062/yearNetwork.json\"\ndata_json = requests.get(data_url).json()\npprint_head(data_json, 10)  # only print first 10 lines\n\n\n{'networkLines': [{'line': [{'value': 26, 'year': '2013'},\n                            {'value': 26, 'year': '2014'},\n                            {'value': 24, 'year': '2015'},\n                            {'value': 24, 'year': '2016'},\n                            {'value': 13, 'year': '2017'}],\n                   'max': 26,\n                   'network': 'AMC',\n                   'total': 113},\n                  {'line': [{'value': 32, 'year': '2013'},\n                            {'value': 24, 'year': '2014'},\n\n\n\n\nConvert json into DataFrame\nOnce we get the json data, we will convert the data into a dataframe. To do that, we use json_normalize function in pandas that will normalize a json (or dict) into a flat dataframe. At the end of the pipeline, we specify data type for each column to make sure that they have the correct data type.\nTips\nUse .pipe(glimpse, info=True) to see data types for each column without leaving the current pipeline\n\n\nCode\ndf = (\n    # convert json into tabular\n    # ref: https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html?highlight=json_normalize#normalization\n    pd.json_normalize(data_json[\"networkLines\"], \"line\", [\"network\", \"total\", \"max\"])\n    # .pipe(glimpse, info=True)\n    # specify data type for numeric variables\n    .astype({\"year\": \"int\", \"value\": \"int\", \"total\": \"int\", \"max\": \"int\"})\n)\ndf\n\n\n\n\n\n\n\n\n\nyear\nvalue\nnetwork\ntotal\nmax\n\n\n\n\n0\n2013\n26\nAMC\n113\n26\n\n\n1\n2014\n26\nAMC\n113\n26\n\n\n2\n2015\n24\nAMC\n113\n26\n\n\n3\n2016\n24\nAMC\n113\n26\n\n\n4\n2017\n13\nAMC\n113\n26\n\n\n...\n...\n...\n...\n...\n...\n\n\n54\n2015\n12\nAmazon\n44\n16\n\n\n55\n2016\n16\nAmazon\n44\n16\n\n\n56\n2017\n16\nAmazon\n44\n16\n\n\n57\n2016\n2\nHulu\n20\n18\n\n\n58\n2017\n18\nHulu\n20\n18\n\n\n\n\n59 rows × 5 columns\n\n\n\n\n\nPivot the Data into Wide Format\nAs we can see above, the dataframe is in long format. That means, each row represents one observation and each column only represent 1 variable or metric.\nFor the next following steps, i.e. visualization, we need to pivot the dataframe into a wide format. After pivoted, each row in the dataframe represents a single year and each column represents values for one network.\n\n\nCode\nyearly_df = (\n    df\n    .copy()\n    .pivot(index=\"year\", columns=\"network\", values=\"value\")\n    # remove column index name\n    .rename_axis(None, axis=1)\n)\nyearly_df\n\n\n\n\n\n\n\n\n\nABC\nAMC\nAmazon\nCBS\nFOX\nFX Networks\nHBO\nHulu\nNBC\nNat Geo\nNetflix\nPBS\nShowtime\n\n\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2013\n45.0\n26.0\nNaN\n54.0\n20.0\n26.0\n109.0\nNaN\n53.0\nNaN\n14.0\n25.0\n32.0\n\n\n2014\n37.0\n26.0\nNaN\n47.0\n21.0\n45.0\n99.0\nNaN\n47.0\n4.0\n31.0\n34.0\n24.0\n\n\n2015\n42.0\n24.0\n12.0\n41.0\n36.0\n39.0\n126.0\nNaN\n43.0\n4.0\n34.0\n30.0\n18.0\n\n\n2016\n35.0\n24.0\n16.0\n35.0\n30.0\n57.0\n94.0\n2.0\n41.0\n10.0\n54.0\n26.0\n22.0\n\n\n2017\n33.0\n13.0\n16.0\n29.0\n20.0\n55.0\n111.0\n18.0\n64.0\n15.0\n91.0\n11.0\n15.0\n\n\n\n\n\n\n\nThose NaN values in the dataframe above mean missing values."
  },
  {
    "objectID": "posts/2021-08-23-recreate-visualization-in-matplotlib.html#visualization",
    "href": "posts/2021-08-23-recreate-visualization-in-matplotlib.html#visualization",
    "title": "Recreate Visualization in Matplotlib",
    "section": "Visualization",
    "text": "Visualization\n\nBasic Line Plot\nFirst thing first, we will plot the basic line plot with year as the x-axis and network value as the y-axis. There will be multiple lines and each line represent one network.\nIt is also useful to get the color map from the orginal chart, so that our chart will have similar color pallette.\n\n\nCode\nfig = plt.figure(figsize=(14, 7))\nax = fig.add_subplot()\n\n# colormap from the original chart\ncolormap = {\n    \"HBO\": \"black\",\n    \"Netflix\": \"#D32F2F\",\n    \"NBC\": \"#ffc107\",\n    \"FX Networks\": \"#0097a7\",\n    \"ABC\": \"#00BFA5\",\n    \"CBS\": \"#00BCD4\",\n    \"FOX\": \"#3f51b5\",\n    \"Showtime\": \"#C5CAE9\",\n    \"AMC\": \"#D32F2F\",\n    \"PBS\": \"#B39DDB\",\n    \"Amazon\": \"#ffc107\",\n    \"Nat Geo\": \"#ff9800\",\n    \"Hulu\": \"#00BFA5\"\n}\n\n# iterate over unique networks\nfor n in df.network.unique():\n    if n in (\"HBO\", \"Netflix\"):\n        ax.plot(yearly_df.index, yearly_df[n], color=colormap[n], label=n)\n    else:\n        ax.plot(yearly_df.index, yearly_df[n], color=colormap[n], label=n, linestyle=\":\")\n\n\n\n\n\nFigure 1: Basic Line Plot\n\n\n\n\nNote that we use two different line styles for the lines. - Solid line for HBO and Netflix, and - Dashed line for the other networks\nNext, we will add the bullet points (scatter plot) on top of the lines\n\n\nScatter Plot\nWe will only apply scatter plot only to Netflix and HBO networks\n\n\nCode\n# scatter point\n# only Netflix and HBO that have points\nax.scatter(x=yearly_df.index, y=yearly_df.Netflix, s=600, zorder=3, color=colormap[\"Netflix\"])\nax.scatter(x=yearly_df.index, y=yearly_df.HBO, s=600, zorder=3, color=colormap[\"HBO\"])\n\n# scatter label\nfor row in yearly_df.itertuples():\n    ax.text(row.Index, row.Netflix, int(row.Netflix),\n            ha=\"center\", va=\"center\",\n            color=\"#fff\",\n            fontweight=\"normal\", fontsize=\"medium\")\n    ax.text(row.Index, row.HBO, int(row.HBO),\n            ha=\"center\", va=\"center\",\n            color=\"#fff\",\n            fontweight=\"normal\", fontsize=\"medium\")\n    \nfig\n\n\n\n\n\nFigure 2: Scatter Plot\n\n\n\n\nIt is important to make sure the labels are vertically (va) and horizontally (ha) centered.\n\n\nLegend\nNext we are going to add legend text in the right-hand side of the chart. To make sure that we have enough space to display the texts, we will set the x-axis value range from 2011 to 2018 (+1 year as an extra whitespace to be filled in by the text)\n\n\nCode\n# legend\nfor n in df.network.unique():\n    if n in (\"HBO\", \"Netflix\"):\n        ax.text(2017.15, yearly_df.loc[2017, n], n.upper(),\n                ha=\"left\", va=\"center\",\n                color=colormap[n],\n                fontweight=\"bold\", fontsize=\"medium\")\n    else:\n        ax.text(2017.05, yearly_df.loc[2017, n], n.upper(),\n                ha=\"left\", va=\"center\",\n                color=colormap[n],\n                fontweight=\"bold\", fontsize=\"medium\")\n        \n# set x axis range\nax.set_xlim([2011, 2018])\nfig\n\n\n\n\n\nFigure 3: Add Legend\n\n\n\n\n\n\nGrid and Axis\nUnlike any other standard charts, the chart has vertical grid lines and the x-axis ticks are written in the middle of the lines. We are going to draw those grid lines and axis texts using vlines and text.\n\n\nCode\n# horizontal bottom line\nax.hlines(xmin=yearly_df.index.min(), xmax=yearly_df.index.max(), y=0, color=\"lightgray\", zorder=1)\n\n# vertical lines\nax.vlines(yearly_df.index, ymin=0, ymax=yearly_df.HBO, color=\"lightgray\", zorder=1)\n\n# x-axis ticks\nfor row in yearly_df.itertuples():\n    ax.text(row.Index, 75, row.Index,\n            ha=\"center\", va=\"center\",\n            backgroundcolor=\"#fff\", color=\"gray\",\n            fontweight=\"bold\",\n            bbox={\"pad\": 5, \"fc\": \"#fff\", \"ec\": \"#fff\"})\n\nfig\n\n\n\n\n\nFigure 4: Grid and Axis\n\n\n\n\n\n\nTitle\nIt is quite tricky to write the title since it has rich formatting (i.e. color, bold, and highlight).\n\n\nCode\n# title\nax.text(2011, 100, \"Netflix\",\n        ha=\"left\", va=\"center\",\n        color=colormap[\"Netflix\"],\n        fontweight=\"bold\", fontsize=30)\n\nax.text(2011, 90, \"Challenges\",\n        ha=\"left\", va=\"center\",\n        fontweight=\"light\", fontsize=30)\n\nax.text(2011, 80, \"HBO at the\",\n        ha=\"left\", va=\"center\",\n        fontweight=\"light\", fontsize=30)\n\nax.text(2011, 70, \"2017 Emmys\",\n        ha=\"left\", va=\"center\",\n        fontweight=\"light\", fontsize=30)\n\nfig\n\n\n\n\n\nFigure 5: Title\n\n\n\n\n\n\nFinal Version\nIn the final version, we combine all the parts above into a single block code.\n\n\nCode\n# colormap from the original chart\ncolormap = {\n    \"HBO\": \"black\",\n    \"Netflix\": \"#D32F2F\",\n    \"NBC\": \"#ffc107\",\n    \"FX Networks\": \"#0097a7\",\n    \"ABC\": \"#00BFA5\",\n    \"CBS\": \"#00BCD4\",\n    \"FOX\": \"#3f51b5\",\n    \"Showtime\": \"#C5CAE9\",\n    \"AMC\": \"#D32F2F\",\n    \"PBS\": \"#B39DDB\",\n    \"Amazon\": \"#ffc107\",\n    \"Nat Geo\": \"#ff9800\",\n    \"Hulu\": \"#00BFA5\"\n}\n\nfig = plt.figure(figsize=(14, 7))\nax = fig.add_subplot()\n\n# horizontal bottom line\nax.hlines(xmin=yearly_df.index.min(), xmax=yearly_df.index.max(), y=0, color=\"lightgray\", zorder=1)\n\n# vertical lines\nax.vlines(yearly_df.index, ymin=0, ymax=yearly_df.HBO, color=\"lightgray\", zorder=1)\n\n# x-axis ticks\nfor row in yearly_df.itertuples():\n    ax.text(row.Index, 75, row.Index,\n            ha=\"center\", va=\"center\",\n            backgroundcolor=\"#fff\", color=\"gray\",\n            fontweight=\"bold\",\n            bbox={\"pad\": 5, \"fc\": \"#fff\", \"ec\": \"#fff\"})\n\n# line plot\nfor n in df.network.unique():\n    if n in (\"HBO\", \"Netflix\"):\n        ax.plot(yearly_df.index, yearly_df[n], color=colormap[n], label=n)\n    else:\n        ax.plot(yearly_df.index, yearly_df[n], color=colormap[n], label=n, linestyle=\":\")\n\n# scatter point\n# only Netflix and HBO that have points\nax.scatter(x=yearly_df.index, y=yearly_df.Netflix, s=600, zorder=3, color=colormap[\"Netflix\"])\nax.scatter(x=yearly_df.index, y=yearly_df.HBO, s=600, zorder=3, color=colormap[\"HBO\"])\n\n# scatter label\nfor row in yearly_df.itertuples():\n    ax.text(row.Index, row.Netflix, int(row.Netflix),\n            ha=\"center\", va=\"center\",\n            color=\"#fff\",\n            fontweight=\"normal\", fontsize=\"medium\")\n    ax.text(row.Index, row.HBO, int(row.HBO),\n            ha=\"center\", va=\"center\",\n            color=\"#fff\",\n            fontweight=\"normal\", fontsize=\"medium\")\n\n# legend\nfor n in df.network.unique():\n    if n in (\"HBO\", \"Netflix\"):\n        ax.text(2017.15, yearly_df.loc[2017, n], n.upper(),\n                ha=\"left\", va=\"center\",\n                color=colormap[n],\n                fontweight=\"bold\", fontsize=\"medium\")\n    else:\n        ax.text(2017.05, yearly_df.loc[2017, n], n.upper(),\n                ha=\"left\", va=\"center\",\n                color=colormap[n],\n                fontweight=\"bold\", fontsize=\"medium\")\n        \n# title\nax.text(2011, 100, \"Netflix\",\n        ha=\"left\", va=\"center\",\n        color=colormap[\"Netflix\"],\n        fontweight=\"bold\", fontsize=30)\n\nax.text(2011, 90, \"Challenges\",\n        ha=\"left\", va=\"center\",\n        fontweight=\"light\", fontsize=30)\n\nax.text(2011, 80, \"HBO at the\",\n        ha=\"left\", va=\"center\",\n        fontweight=\"light\", fontsize=30)\n\nax.text(2011, 70, \"2017 Emmys\",\n        ha=\"left\", va=\"center\",\n        fontweight=\"light\", fontsize=30)\n\nax.set_xlim([2011, 2018])\nax.set_axis_off()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nFigure 6: Final Version\n\n\n\n\n\n\nMissing Parts\nIf you notice, the parts are reordered (e.g. grid lines are first) to make sure their layering stacks. Elements on the upper layers (displayed later) shouldn’t be occluded by any elements on the bottom layers.\nThe result above is already pretty much similar with the original visualization. However, we still have some missing / uncovered parts:\n\nFont family\nI use default font family. As consequences, the font look are not the same as in the original chart.\nRich title\nI found that it is not straight forward to write a rich texh format for chart title\nAvoid text overlap\nAs you might see on the legend texts (right-hand side) that the text are overlapped each other and unreadable. I haven’t found solution for this issue."
  },
  {
    "objectID": "posts/2022-12-13-pandas-number-formatting.html",
    "href": "posts/2022-12-13-pandas-number-formatting.html",
    "title": "Pandas Number Formatting",
    "section": "",
    "text": "In many cases we need to apply different number formatting to different columns. One column might need to use currency format, while the other need to use percent format.\nIn this case, Pandas has Styler.format feature to do this (ref). We just need to define the formatting function for columns we want to apply on using dictionary where each key represents column name and the value represents formatting function.\nHere is the example.\nLet’s use this sample data.\n\n\nCode\ndf = pd.read_csv(\"https://gist.githubusercontent.com/arifqodari/08692800e902401860c7ab4f94c2390c/raw/8e6e4e5c85ab091d6ac21801c2fe02fa6dd1fc77/sales_dummy.csv\")\ndf\n\n\n\n\n\n\n\n\n\ndate\ntotal_sales\nrevenue\nrate\n\n\n\n\n0\n2023-01-01\n923\n10400500\n0.046723\n\n\n1\n2023-01-02\n1104\n11299050\n0.050123\n\n\n2\n2023-01-03\n987\n10904500\n0.040111\n\n\n\n\n\n\n\nNext, we can define and apply the formatting function.\n\nformat_mapping = {\n    \"revenue\": \"{:,} IDR\",\n    \"rate\": \"{:,.2%}\"\n}\n\ndf.style.format(format_mapping)\n\n\n\n\n\n\n \ndate\ntotal_sales\nrevenue\nrate\n\n\n\n\n0\n2023-01-01\n923\n10,400,500 IDR\n4.67%\n\n\n1\n2023-01-02\n1104\n11,299,050 IDR\n5.01%\n\n\n2\n2023-01-03\n987\n10,904,500 IDR\n4.01%\n\n\n\n\n\nNeat!\nThe script above only apply formatting to certain columns defined in the format_mapping dictionary. Here is the explanation:\n\nrevenue column needs thousand separator using comma (,)\nrate column need to be presented as percentage.\nNote that the original value is not in the percentage yet."
  },
  {
    "objectID": "posts/2022-01-30-calculating-a-forward-looking-moving-average-in-pandas.html",
    "href": "posts/2022-01-30-calculating-a-forward-looking-moving-average-in-pandas.html",
    "title": "Calculating a Forward-Looking Moving Average in Pandas",
    "section": "",
    "text": "Code\nimport pandas as pd"
  },
  {
    "objectID": "posts/2022-01-30-calculating-a-forward-looking-moving-average-in-pandas.html#question",
    "href": "posts/2022-01-30-calculating-a-forward-looking-moving-average-in-pandas.html#question",
    "title": "Calculating a Forward-Looking Moving Average in Pandas",
    "section": "Question",
    "text": "Question\nGiven a data with a column named n that contains a list of integer numbers. Calculate a moving average with a window size = 3!\n\n\nCode\ndf = pd.DataFrame({\"n\": [20, 44, 46, 23, 10, 80, 52, 64, 87, 77]})\ndf\n\n\n\n\n\n\n\n\n\nn\n\n\n\n\n0\n20\n\n\n1\n44\n\n\n2\n46\n\n\n3\n23\n\n\n4\n10\n\n\n5\n80\n\n\n6\n52\n\n\n7\n64\n\n\n8\n87\n\n\n9\n77"
  },
  {
    "objectID": "posts/2022-01-30-calculating-a-forward-looking-moving-average-in-pandas.html#solution",
    "href": "posts/2022-01-30-calculating-a-forward-looking-moving-average-in-pandas.html#solution",
    "title": "Calculating a Forward-Looking Moving Average in Pandas",
    "section": "Solution",
    "text": "Solution\nThere is a function pandas.DataFrame.rolling that we can use to do moving window calculation. In this particular case, we will calculate mean in each window.\n\n\nCode\n(\n    df\n    .assign(\n        moving_average=lambda dfx: dfx.n.rolling(window=3).mean()\n    )\n)\n\n\n\n\n\n\n\n\n\nn\nmoving_average\n\n\n\n\n0\n20\nNaN\n\n\n1\n44\nNaN\n\n\n2\n46\n36.666667\n\n\n3\n23\n37.666667\n\n\n4\n10\n26.333333\n\n\n5\n80\n37.666667\n\n\n6\n52\n47.333333\n\n\n7\n64\n65.333333\n\n\n8\n87\n67.666667\n\n\n9\n77\n76.000000\n\n\n\n\n\n\n\nOK. So far so good. In the above code, we calculate a moving average using window size = 3 and then assign the result in a new column named moving_average.\nThe first two rows are NaN because the rolling function look the values backward. For example when using window size = 3, each window calculate values from position current row - 2 until current row. Hence, the NaN values are there because we can’t calculate mean from less than 3 (window size).\nWhat if what we want is to calculate a forward-looking moving average? That means a window must contain values from position current row until the next 2 rows ahead before calculating the mean. To do that we need a special window indexer called pandas.api.indexers.FixedForwardWindowIndexer.\nHere is what we can do.\n\n\nCode\nwindow = pd.api.indexers.FixedForwardWindowIndexer(window_size=3)\n(\n    df\n    .assign(\n        moving_average=lambda dfx: dfx.n.rolling(window=window).mean()\n    )\n)\n\n\n\n\n\n\n\n\n\nn\nmoving_average\n\n\n\n\n0\n20\n36.666667\n\n\n1\n44\n37.666667\n\n\n2\n46\n26.333333\n\n\n3\n23\n37.666667\n\n\n4\n10\n47.333333\n\n\n5\n80\n65.333333\n\n\n6\n52\n67.666667\n\n\n7\n64\n76.000000\n\n\n8\n87\nNaN\n\n\n9\n77\nNaN\n\n\n\n\n\n\n\nThe code is similar with the previous one, but now we specify a window parameter in rolling function using a special window indexer function.\nThen, Voila! The result is as expected."
  },
  {
    "objectID": "posts/2022-08-01-tidying-dataframe-column-names.html",
    "href": "posts/2022-08-01-tidying-dataframe-column-names.html",
    "title": "Tidying Dataframe Column Names",
    "section": "",
    "text": "Let’s use this sample data.\n\n\nCode\ndf = pd.read_csv(\"https://gist.githubusercontent.com/arifqodari/965b854469b279df026e305864a944c0/raw/43984c8596373d64e602717ed6c3313393c85b2e/flight_dummy.csv\")\ndf\n\n\n\n\n\n\n\n\n\nflightNumber\nAirline Name\ndeparture date_time\n\n\n\n\n0\nQZ-274\nAirAsia Indonesia\n2023-11-22 20:30\n\n\n1\nQG-526\nCitilink\n2023-11-22 16:20\n\n\n2\nQG-522\nCitilink\n2023-11-22 06:00\n\n\n\n\n\n\n\nNext, let’s define our method tidy_columns containing series of functions to tidy up the column names. Then apply the function to the dataframe above.\n\ndef camel_to_snake(str_):\n    str_ = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1 \\2\", str_)\n    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1 \\2\", str_).lower()\n\ndef whitespace_to_underscore(str_):\n    return re.sub(\"\\s+\", \"_\", str_)\n\ndef tidy_columns(df):\n    df.columns = (\n        df.columns\n        .str.strip()  # strip text\n        .map(camel_to_snake)  # change to snake case\n        .map(whitespace_to_underscore)  # change any whitespace to underscore\n        .str.lower()  # lowercase\n        .str.replace(\"(\", \"\")\n        .str.replace(\")\", \"\")\n    )\n    return df\n\n\ntidy_df = tidy_columns(df)\ntidy_df\n\n\n\n\n\n\n\n\nflight_number\nairline_name\ndeparture_date_time\n\n\n\n\n0\nQZ-274\nAirAsia Indonesia\n2023-11-22 20:30\n\n\n1\nQG-526\nCitilink\n2023-11-22 16:20\n\n\n2\nQG-522\nCitilink\n2023-11-22 06:00\n\n\n\n\n\n\n\nNeat! The simple method above tidy_columns do the following:\n\nstrip trailing whitespace\nchange from camel case to snake case (if any)\nreplace any whitespace (e.g. space) to underscore\nchange case to lowercase\nremove parentheses\n\nIf you think that it needs additional treatment, you can simply create another function that accept a string and return a string and put another .map(your_function) in the tidy function above."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tech Notes",
    "section": "",
    "text": "Pandas Number Formatting\n\n\n\n\n\n\n\n\n\n\n\n\nDec 13, 2022\n\n\n1 min\n\n\n\n\n\n\n\n\nTidying Dataframe Column Names\n\n\n\n\n\nA simple script to tidying up messing column names in pandas dataframe\n\n\n\n\n\n\nAug 1, 2022\n\n\n1 min\n\n\n\n\n\n\n\n\nCalculating a Forward-Looking Moving Average in Pandas\n\n\n\n\n\n\n\n\n\n\n\n\nJan 30, 2022\n\n\n1 min\n\n\n\n\n\n\n\n\nRecreate Visualization in Matplotlib\n\n\n\n\n\n\n\n\n\n\n\n\nAug 23, 2021\n\n\n3 min\n\n\n\n\n\n\nNo matching items"
  }
]